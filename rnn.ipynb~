{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "initial_id",
   "metadata": {
    "collapsed": true,
    "ExecuteTime": {
     "end_time": "2024-05-21T08:24:11.849915900Z",
     "start_time": "2024-05-21T08:23:59.252394600Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training Start\n",
      "Epoch:    0, Loss: 0.17931\n",
      "Epoch:   64, Loss: 0.01201\n",
      "Epoch:  128, Loss: 0.00504\n",
      "Epoch:  192, Loss: 0.00204\n",
      "Epoch:  256, Loss: 0.00153\n",
      "Epoch:  320, Loss: 0.00129\n",
      "Save in: ./net.pth\n",
      "L1: 0.190    L2: 0.060\n"
     ]
    },
    {
     "data": {
      "text/plain": "<Figure size 432x288 with 1 Axes>",
      "image/png": "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\n"
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import torch\n",
    "from torch import nn\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\"\"\"\n",
    "Github: Yonv1943 Zen4 Jia1 hao2\n",
    "https://github.com/Yonv1943/DL_RL_Zoo/blob/master/RNN\n",
    "\n",
    "The source of training data \n",
    "https://github.com/L1aoXingyu/\n",
    "code-of-learn-deep-learning-with-pytorch/blob/master/\n",
    "chapter5_RNN/time-series/lstm-time-series.ipynb\n",
    "\"\"\"\n",
    "\n",
    "\n",
    "def run_train_gru():\n",
    "    inp_dim = 3\n",
    "    out_dim = 1\n",
    "    batch_size = 12 * 4\n",
    "\n",
    "    '''load data'''\n",
    "    data = load_data()\n",
    "    data_x = data[:-1, :]\n",
    "    data_y = data[+1:, 0]\n",
    "    assert data_x.shape[1] == inp_dim\n",
    "\n",
    "    train_size = int(len(data_x) * 0.75)\n",
    "\n",
    "    train_x = data_x[:train_size]\n",
    "    train_y = data_y[:train_size]\n",
    "    train_x = train_x.reshape((train_size, inp_dim))\n",
    "    train_y = train_y.reshape((train_size, out_dim))\n",
    "\n",
    "    '''build model'''\n",
    "    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "    net = RegGRU(inp_dim, out_dim, mod_dim=12, mid_layers=2).to(device)\n",
    "    criterion = nn.MSELoss()\n",
    "    optimizer = torch.optim.Adam(net.parameters(), lr=1e-2)\n",
    "\n",
    "    '''train'''\n",
    "    var_x = torch.tensor(train_x, dtype=torch.float32, device=device)\n",
    "    var_y = torch.tensor(train_y, dtype=torch.float32, device=device)\n",
    "\n",
    "    batch_var_x = list()\n",
    "    batch_var_y = list()\n",
    "\n",
    "    for i in range(batch_size):\n",
    "        j = train_size - i\n",
    "        batch_var_x.append(var_x[j:])\n",
    "        batch_var_y.append(var_y[j:])\n",
    "\n",
    "    from torch.nn.utils.rnn import pad_sequence\n",
    "    batch_var_x = pad_sequence(batch_var_x)\n",
    "    batch_var_y = pad_sequence(batch_var_y)\n",
    "\n",
    "    with torch.no_grad():\n",
    "        weights = np.tanh(np.arange(len(train_y)) * (np.e / len(train_y)))\n",
    "        weights = torch.tensor(weights, dtype=torch.float32, device=device)\n",
    "\n",
    "    for e in range(256):\n",
    "        out = net(batch_var_x)\n",
    "\n",
    "        # loss = criterion(out, batch_var_y)\n",
    "        loss = (out - batch_var_y) ** 2 * weights\n",
    "        loss = loss.mean()\n",
    "\n",
    "        optimizer.zero_grad()\n",
    "        loss.backward()\n",
    "        optimizer.step()\n",
    "\n",
    "        if e % 100 == 0:\n",
    "            print('Epoch: {}, Loss: {:.5f}'.format(e, loss.item()))\n",
    "\n",
    "    '''eval'''\n",
    "    net = net.eval()\n",
    "\n",
    "    test_x = data_x.copy()\n",
    "    test_x[train_size:, 0] = 0\n",
    "    test_x = test_x[:, np.newaxis, :]\n",
    "    test_x = torch.tensor(test_x, dtype=torch.float32, device=device)\n",
    "    for i in range(train_size, len(data) - 2):\n",
    "        test_y = net(test_x[:i])\n",
    "        test_x[i + 1, 0, 0] = test_y[-1]\n",
    "    pred_y = test_x[1:, 0, 0]\n",
    "    pred_y = pred_y.cpu().data.numpy()\n",
    "\n",
    "    diff_y = pred_y[train_size:] - data_y[train_size:-1]\n",
    "    l1_loss = np.mean(np.abs(diff_y))\n",
    "    l2_loss = np.mean(diff_y ** 2)\n",
    "    print(\"L1: {:.3f}    L2: {:.3f}\".format(l1_loss, l2_loss))\n",
    "    plt.plot(pred_y, 'r', label='pred')\n",
    "    plt.plot(data_y, 'b', label='real')\n",
    "    plt.legend(loc='best')\n",
    "    plt.pause(4)\n",
    "\n",
    "\n",
    "def run_train_lstm():\n",
    "    inp_dim = 3\n",
    "    out_dim = 1\n",
    "    mid_dim = 8\n",
    "    mid_layers = 1\n",
    "    batch_size = 12 * 4\n",
    "    mod_dir = '.'\n",
    "\n",
    "    '''load data'''\n",
    "    data = load_data()\n",
    "    data_x = data[:-1, :]\n",
    "    data_y = data[+1:, 0]\n",
    "    assert data_x.shape[1] == inp_dim\n",
    "\n",
    "    train_size = int(len(data_x) * 0.75)\n",
    "\n",
    "    train_x = data_x[:train_size]\n",
    "    train_y = data_y[:train_size]\n",
    "    train_x = train_x.reshape((train_size, inp_dim))\n",
    "    train_y = train_y.reshape((train_size, out_dim))\n",
    "\n",
    "    '''build model'''\n",
    "    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "    net = RegLSTM(inp_dim, out_dim, mid_dim, mid_layers).to(device)\n",
    "    criterion = nn.MSELoss()\n",
    "    optimizer = torch.optim.Adam(net.parameters(), lr=1e-2)\n",
    "\n",
    "    '''train'''\n",
    "    var_x = torch.tensor(train_x, dtype=torch.float32, device=device)\n",
    "    var_y = torch.tensor(train_y, dtype=torch.float32, device=device)\n",
    "\n",
    "    batch_var_x = list()\n",
    "    batch_var_y = list()\n",
    "\n",
    "    for i in range(batch_size):\n",
    "        j = train_size - i\n",
    "        batch_var_x.append(var_x[j:])\n",
    "        batch_var_y.append(var_y[j:])\n",
    "\n",
    "    from torch.nn.utils.rnn import pad_sequence\n",
    "    batch_var_x = pad_sequence(batch_var_x)\n",
    "    batch_var_y = pad_sequence(batch_var_y)\n",
    "\n",
    "    with torch.no_grad():\n",
    "        weights = np.tanh(np.arange(len(train_y)) * (np.e / len(train_y)))\n",
    "        weights = torch.tensor(weights, dtype=torch.float32, device=device)\n",
    "\n",
    "    print(\"Training Start\")\n",
    "    for e in range(384):\n",
    "        out = net(batch_var_x)\n",
    "    \n",
    "        # loss = criterion(out, batch_var_y)\n",
    "        loss = (out - batch_var_y) ** 2 * weights\n",
    "        loss = loss.mean()\n",
    "    \n",
    "        optimizer.zero_grad()\n",
    "        loss.backward()\n",
    "        optimizer.step()\n",
    "    \n",
    "        if e % 64 == 0:\n",
    "            print('Epoch: {:4}, Loss: {:.5f}'.format(e, loss.item()))\n",
    "    torch.save(net.state_dict(), '{}/net.pth'.format(mod_dir))\n",
    "    print(\"Save in:\", '{}/net.pth'.format(mod_dir))\n",
    "\n",
    "    '''eval'''\n",
    "    net.load_state_dict(torch.load('{}/net.pth'.format(mod_dir), map_location=lambda storage, loc: storage))\n",
    "    net = net.eval()\n",
    "\n",
    "    test_x = data_x.copy()\n",
    "    test_x[train_size:, 0] = 0\n",
    "    test_x = test_x[:, np.newaxis, :]\n",
    "    test_x = torch.tensor(test_x, dtype=torch.float32, device=device)\n",
    "\n",
    "    '''simple way but no elegant'''\n",
    "    # for i in range(train_size, len(data) - 2):\n",
    "    #     test_y = net(test_x[:i])\n",
    "    #     test_x[i, 0, 0] = test_y[-1]\n",
    "\n",
    "    '''elegant way but slightly complicated'''\n",
    "    eval_size = 1\n",
    "    zero_ten = torch.zeros((mid_layers, eval_size, mid_dim), dtype=torch.float32, device=device)\n",
    "    test_y, hc = net.output_y_hc(test_x[:train_size], (zero_ten, zero_ten))\n",
    "    test_x[train_size + 1, 0, 0] = test_y[-1]\n",
    "    for i in range(train_size + 1, len(data) - 2):\n",
    "        test_y, hc = net.output_y_hc(test_x[i:i + 1], hc)\n",
    "        test_x[i + 1, 0, 0] = test_y[-1]\n",
    "    pred_y = test_x[1:, 0, 0]\n",
    "    pred_y = pred_y.cpu().data.numpy()\n",
    "\n",
    "    diff_y = pred_y[train_size:] - data_y[train_size:-1]\n",
    "    l1_loss = np.mean(np.abs(diff_y))\n",
    "    l2_loss = np.mean(diff_y ** 2)\n",
    "    print(\"L1: {:.3f}    L2: {:.3f}\".format(l1_loss, l2_loss))\n",
    "\n",
    "    plt.plot(pred_y, 'r', label='pred')\n",
    "    plt.plot(data_y, 'b', label='real', alpha=0.3)\n",
    "    plt.plot([train_size, train_size], [-1, 2], color='k', label='train | pred')\n",
    "    plt.legend(loc='best')\n",
    "    plt.savefig('lstm_reg.png')\n",
    "    plt.pause(4)\n",
    "\n",
    "\n",
    "def run_origin():\n",
    "    inp_dim = 2\n",
    "    out_dim = 1\n",
    "    mod_dir = '.'\n",
    "\n",
    "    '''load data'''\n",
    "    data = load_data()  # axis1: number, year, month\n",
    "    data_x = np.concatenate((data[:-2, 0:1], data[+1:-1, 0:1]), axis=1)\n",
    "    data_y = data[2:, 0]\n",
    "\n",
    "    train_size = int(len(data_x) * 0.75)\n",
    "    train_x = data_x[:train_size]\n",
    "    train_y = data_y[:train_size]\n",
    "\n",
    "    train_x = train_x.reshape((-1, 1, inp_dim))\n",
    "    train_y = train_y.reshape((-1, 1, out_dim))\n",
    "\n",
    "    '''build model'''\n",
    "    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "    net = RegLSTM(inp_dim, out_dim, mid_dim=4, mid_layers=2).to(device)\n",
    "    criterion = nn.SmoothL1Loss()\n",
    "    optimizer = torch.optim.Adam(net.parameters(), lr=1e-2)\n",
    "\n",
    "    '''train'''\n",
    "    var_x = torch.tensor(train_x, dtype=torch.float32, device=device)\n",
    "    var_y = torch.tensor(train_y, dtype=torch.float32, device=device)\n",
    "    print('var_x.size():', var_x.size())\n",
    "    print('var_y.size():', var_y.size())\n",
    "\n",
    "    for e in range(512):\n",
    "        out = net(var_x)\n",
    "        loss = criterion(out, var_y)\n",
    "\n",
    "        optimizer.zero_grad()\n",
    "        loss.backward()\n",
    "        optimizer.step()\n",
    "\n",
    "        if (e + 1) % 100 == 0:  # 每 100 次输出结果\n",
    "            print('Epoch: {}, Loss: {:.5f}'.format(e + 1, loss.item()))\n",
    "\n",
    "    torch.save(net.state_dict(), '{}/net.pth'.format(mod_dir))\n",
    "\n",
    "    '''eval'''\n",
    "    # net.load_state_dict(torch.load('{}/net.pth'.format(mod_dir), map_location=lambda storage, loc: storage))\n",
    "    net = net.eval()  # 转换成测试模式\n",
    "\n",
    "    \"\"\"\n",
    "    inappropriate way of seq prediction: \n",
    "    use all real data to predict the number of next month\n",
    "    \"\"\"\n",
    "    test_x = data_x.reshape((-1, 1, inp_dim))\n",
    "    var_data = torch.tensor(test_x, dtype=torch.float32, device=device)\n",
    "    eval_y = net(var_data)  # 测试集的预测结果\n",
    "    pred_y = eval_y.view(-1).cpu().data.numpy()\n",
    "\n",
    "    plt.plot(pred_y[1:], 'r', label='pred inappr', alpha=0.3)\n",
    "    plt.plot(data_y, 'b', label='real', alpha=0.3)\n",
    "    plt.plot([train_size, train_size], [-1, 2], label='train | pred')\n",
    "\n",
    "    \"\"\"\n",
    "    appropriate way of seq prediction: \n",
    "    use real+pred data to predict the number of next 3 years.\n",
    "    \"\"\"\n",
    "    test_x = data_x.reshape((-1, 1, inp_dim))\n",
    "    test_x[train_size:] = 0  # delete the data of next 3 years.\n",
    "    test_x = torch.tensor(test_x, dtype=torch.float32, device=device)\n",
    "    for i in range(train_size, len(data) - 2):\n",
    "        test_y = net(test_x[:i])\n",
    "        test_x[i, 0, 0] = test_x[i - 1, 0, 1]\n",
    "        test_x[i, 0, 1] = test_y[-1, 0]\n",
    "    pred_y = test_x.cpu().data.numpy()\n",
    "    pred_y = pred_y[:, 0, 0]\n",
    "    plt.plot(pred_y[2:], 'g', label='pred appr')\n",
    "\n",
    "    plt.legend(loc='best')\n",
    "    plt.savefig('lstm_origin.png')\n",
    "    plt.pause(4)\n",
    "\n",
    "\n",
    "class RegLSTM(nn.Module):\n",
    "    def __init__(self, inp_dim, out_dim, mid_dim, mid_layers):\n",
    "        super(RegLSTM, self).__init__()\n",
    "\n",
    "        self.rnn = nn.LSTM(inp_dim, mid_dim, mid_layers)  # rnn\n",
    "        self.reg = nn.Sequential(\n",
    "            nn.Linear(mid_dim, mid_dim),\n",
    "            nn.Tanh(),\n",
    "            nn.Linear(mid_dim, out_dim),\n",
    "        )  # regression\n",
    "\n",
    "    def forward(self, x):\n",
    "        y = self.rnn(x)[0]  # y, (h, c) = self.rnn(x)\n",
    "\n",
    "        seq_len, batch_size, hid_dim = y.shape\n",
    "        y = y.view(-1, hid_dim)\n",
    "        y = self.reg(y)\n",
    "        y = y.view(seq_len, batch_size, -1)\n",
    "        return y\n",
    "\n",
    "    \"\"\"\n",
    "    PyCharm Crtl+click nn.LSTM() jump to code of PyTorch:\n",
    "    Examples::\n",
    "        >>> rnn = nn.LSTM(10, 20, 2)\n",
    "        >>> input = torch.randn(5, 3, 10)\n",
    "        >>> h0 = torch.randn(2, 3, 20)\n",
    "        >>> c0 = torch.randn(2, 3, 20)\n",
    "        >>> output, (hn, cn) = rnn(input, (h0, c0))\n",
    "    \"\"\"\n",
    "\n",
    "    def output_y_hc(self, x, hc):\n",
    "        y, hc = self.rnn(x, hc)  # y, (h, c) = self.rnn(x)\n",
    "\n",
    "        seq_len, batch_size, hid_dim = y.size()\n",
    "        y = y.view(-1, hid_dim)\n",
    "        y = self.reg(y)\n",
    "        y = y.view(seq_len, batch_size, -1)\n",
    "        return y, hc\n",
    "\n",
    "\n",
    "class RegGRU(nn.Module):\n",
    "    def __init__(self, inp_dim, out_dim, mod_dim, mid_layers):\n",
    "        super(RegGRU, self).__init__()\n",
    "\n",
    "        self.rnn = nn.GRU(inp_dim, mod_dim, mid_layers)\n",
    "        self.reg = nn.Linear(mod_dim, out_dim)\n",
    "\n",
    "    def forward(self, x):\n",
    "        x, h = self.rnn(x)  # (seq, batch, hidden)\n",
    "\n",
    "        seq_len, batch_size, hid_dim = x.shape\n",
    "        x = x.view(-1, hid_dim)\n",
    "        x = self.reg(x)\n",
    "        x = x.view(seq_len, batch_size, -1)\n",
    "        return x\n",
    "\n",
    "    def output_y_h(self, x, h):\n",
    "        y, h = self.rnn(x, h)\n",
    "\n",
    "        seq_len, batch_size, hid_dim = y.size()\n",
    "        y = y.view(-1, hid_dim)\n",
    "        y = self.reg(y)\n",
    "        y = y.view(seq_len, batch_size, -1)\n",
    "        return y, h\n",
    "\n",
    "\n",
    "def load_data():\n",
    "    # passengers number of international airline , 1949-01 ~ 1960-12 per month\n",
    "    seq_number = np.array(\n",
    "        [112., 118., 132., 129., 121., 135., 148., 148., 136., 119., 104.,\n",
    "         118., 115., 126., 141., 135., 125., 149., 170., 170., 158., 133.,\n",
    "         114., 140., 145., 150., 178., 163., 172., 178., 199., 199., 184.,\n",
    "         162., 146., 166., 171., 180., 193., 181., 183., 218., 230., 242.,\n",
    "         209., 191., 172., 194., 196., 196., 236., 235., 229., 243., 264.,\n",
    "         272., 237., 211., 180., 201., 204., 188., 235., 227., 234., 264.,\n",
    "         302., 293., 259., 229., 203., 229., 242., 233., 267., 269., 270.,\n",
    "         315., 364., 347., 312., 274., 237., 278., 284., 277., 317., 313.,\n",
    "         318., 374., 413., 405., 355., 306., 271., 306., 315., 301., 356.,\n",
    "         348., 355., 422., 465., 467., 404., 347., 305., 336., 340., 318.,\n",
    "         362., 348., 363., 435., 491., 505., 404., 359., 310., 337., 360.,\n",
    "         342., 406., 396., 420., 472., 548., 559., 463., 407., 362., 405.,\n",
    "         417., 391., 419., 461., 472., 535., 622., 606., 508., 461., 390.,\n",
    "         432.], dtype=np.float32)\n",
    "    # assert seq_number.shape == (144, )\n",
    "    # plt.plot(seq_number)\n",
    "    # plt.ion()\n",
    "    # plt.pause(1)\n",
    "    seq_number = seq_number[:, np.newaxis]\n",
    "\n",
    "    # print(repr(seq))\n",
    "    # 1949~1960, 12 years, 12*12==144 month\n",
    "    seq_year = np.arange(12)\n",
    "    seq_month = np.arange(12)\n",
    "    seq_year_month = np.transpose(\n",
    "        [np.repeat(seq_year, len(seq_month)),\n",
    "         np.tile(seq_month, len(seq_year))],\n",
    "    )  # Cartesian Product\n",
    "\n",
    "    seq = np.concatenate((seq_number, seq_year_month), axis=1)\n",
    "\n",
    "    # normalization\n",
    "    seq = (seq - seq.mean(axis=0)) / seq.std(axis=0)\n",
    "    return seq\n",
    "\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    run_train_lstm()\n",
    "    # run_train_gru()\n",
    "    # run_origin()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
